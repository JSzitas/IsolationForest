fitted_forest <- ranger::ranger( random_response_isof~.,
data = X,
mtry,
min.node.size = 1L,
splitrule = "extratrees",
num.random.splits = 1L,
num.trees = n_tree,
replace = replace_smpl,
sample.fraction = smpl_frac,
respect.unordered.factors = respect_unord_fact,
num.threads = n_threads )
# terminal depth
depth_terminal <- function( forest )
{
# workaround for cran - undefined variables problem
id_node <- NULL
depth <- NULL
terminal_depth <-
future.apply::future_lapply( 1:forest[["num.trees"]],
function(i){
# this extracts the i-th tree
tree <- ranger::treeInfo(forest, i)
# process tree
orig_tree <- data.table::data.table(tree)
tree <- data.table::melt( orig_tree[, c("nodeID", "leftChild", "rightChild")],
id.vars = "nodeID",
measure.vars = c("leftChild", "rightChild"),
na.rm = TRUE )
# create graph in 1-index mode
edgeMat     = as.matrix(tree[ , c("nodeID", "value")]) + 1L
treegraph   = igraph::graph_from_edgelist(edgeMat, directed = TRUE)
# get depths of terminal nodes
tnValues    = orig_tree[["nodeID"]][orig_tree[["terminal"]]]
depths      = igraph::distances(treegraph
, v    = 1L
, to   = tnValues + 1L # to 1-index mode
, mode = "out"
)
dim(depths) = NULL
res = data.table::data.table(id_node = tnValues, depth = depths)
return(res)})
terminal_depth = data.table::rbindlist(terminal_depth, idcol = "id_tree")
terminal_depth[ , id_node := as.integer(id_node)]
terminal_depth[ , depth   := as.integer(depth)]
return(terminal_depth)
}
terminal_nodes <- depth_terminal(fitted_forest)
return(terminal_nodes)
# generate predictions from the fitted forest object
predictions <-
data.table::data.table( stats::predict( object = fitted_forest,
data = X,
type = "terminalNodes",
num.threads = n_threads )[["predictions"]])
return(predictions)
}
see <- isolation_forest(data)
View(see)
View(see)
source('C:/Users/juraj/git_hub/IsolationForest/R/new_isolation_forest.R')
isolation_forest <- function( X,
n_tree = 100,
smpl_frac = 0.623,
mtry = NULL,
seed = 1071,
replace_smpl = FALSE,
respect_unord_fact = NULL,
n_threads = NULL )
{
set.seed(seed)
# 'response' variable is really just random noise
random_response_isof <- sample(1:nrow(X), nrow(X))
X <- data.frame(random_response_isof, X)
# fit ranger forest object
fitted_forest <- ranger::ranger( random_response_isof~.,
data = X,
mtry,
min.node.size = 1L,
splitrule = "extratrees",
num.random.splits = 1L,
num.trees = n_tree,
replace = replace_smpl,
sample.fraction = smpl_frac,
respect.unordered.factors = respect_unord_fact,
num.threads = n_threads )
# terminal depth
depth_terminal <- function( forest )
{
# workaround for cran - undefined variables problem
id_node <- NULL
depth <- NULL
terminal_depth <-
future.apply::future_lapply( 1:forest[["num.trees"]],
function(i){
# this extracts the i-th tree
tree <- ranger::treeInfo(forest, i)
# process tree
orig_tree <- data.table::data.table(tree)
tree <- data.table::melt( orig_tree[, c("nodeID", "leftChild", "rightChild")],
id.vars = "nodeID",
measure.vars = c("leftChild", "rightChild"),
na.rm = TRUE )
# create graph in 1-index mode
edgeMat     = as.matrix(tree[ , c("nodeID", "value")]) + 1L
treegraph   = igraph::graph_from_edgelist(edgeMat, directed = TRUE)
# get depths of terminal nodes
tnValues    = orig_tree[["nodeID"]][orig_tree[["terminal"]]]
depths      = igraph::distances(treegraph
, v    = 1L
, to   = tnValues + 1L # to 1-index mode
, mode = "out"
)
dim(depths) = NULL
res = data.table::data.table(id_node = tnValues, depth = depths)
return(res)})
terminal_depth = data.table::rbindlist(terminal_depth, idcol = "id_tree")
terminal_depth[ , id_node := as.integer(id_node)]
terminal_depth[ , depth   := as.integer(depth)]
return(terminal_depth)
}
terminal_nodes <- depth_terminal(fitted_forest)
return(terminal_nodes)
# generate predictions from the fitted forest object
predictions <-
data.table::data.table( stats::predict( object = fitted_forest,
data = X,
type = "terminalNodes",
num.threads = n_threads )[["predictions"]])
return(predictions)
data.table::setnames( predictions,
colnames(predictions),
as.character(1:ncol(predictions)))
predictions[, id := .I]
predictions <- data.table::melt( predictions,
id.vars = "id",
variable.name = "id_tree",
value = "id_node",
variable.factor = FALSE )
id_tree = NULL
id_node = NULL
predictions[, id_tree := as.integer(id_tree)]
predictions[, id_node := as.integer(id_node)]
obs_depth = merge( predictions,
terminal_nodes,
by = c("id_tree", "id_node"))
return(predictions)
}
see <- isolation_forest(data)
View(see)
isolation_forest <- function( X,
n_tree = 100,
smpl_frac = 0.623,
mtry = NULL,
seed = 1071,
replace_smpl = FALSE,
respect_unord_fact = NULL,
n_threads = NULL )
{
set.seed(seed)
# 'response' variable is really just random noise
random_response_isof <- sample(1:nrow(X), nrow(X))
X <- data.frame(random_response_isof, X)
# fit ranger forest object
fitted_forest <- ranger::ranger( random_response_isof~.,
data = X,
mtry,
min.node.size = 1L,
splitrule = "extratrees",
num.random.splits = 1L,
num.trees = n_tree,
replace = replace_smpl,
sample.fraction = smpl_frac,
respect.unordered.factors = respect_unord_fact,
num.threads = n_threads )
# terminal depth
depth_terminal <- function( forest )
{
# workaround for cran - undefined variables problem
id_node <- NULL
depth <- NULL
terminal_depth <-
future.apply::future_lapply( 1:forest[["num.trees"]],
function(i){
# this extracts the i-th tree
tree <- ranger::treeInfo(forest, i)
# process tree
orig_tree <- data.table::data.table(tree)
tree <- data.table::melt( orig_tree[, c("nodeID", "leftChild", "rightChild")],
id.vars = "nodeID",
measure.vars = c("leftChild", "rightChild"),
na.rm = TRUE )
# create graph in 1-index mode
edgeMat     = as.matrix(tree[ , c("nodeID", "value")]) + 1L
treegraph   = igraph::graph_from_edgelist(edgeMat, directed = TRUE)
# get depths of terminal nodes
tnValues    = orig_tree[["nodeID"]][orig_tree[["terminal"]]]
depths      = igraph::distances(treegraph
, v    = 1L
, to   = tnValues + 1L # to 1-index mode
, mode = "out"
)
dim(depths) = NULL
res = data.table::data.table(id_node = tnValues, depth = depths)
return(res)})
terminal_depth = data.table::rbindlist(terminal_depth, idcol = "id_tree")
terminal_depth[ , id_node := as.integer(id_node)]
terminal_depth[ , depth   := as.integer(depth)]
return(terminal_depth)
}
terminal_nodes <- depth_terminal(fitted_forest)
# return(terminal_nodes)
# generate predictions from the fitted forest object
predictions <-
data.table::data.table( stats::predict( object = fitted_forest,
data = X,
type = "terminalNodes",
num.threads = n_threads )[["predictions"]])
return(predictions)
data.table::setnames( predictions,
colnames(predictions),
as.character(1:ncol(predictions)))
predictions[, id := .I]
predictions <- data.table::melt( predictions,
id.vars = "id",
variable.name = "id_tree",
value = "id_node",
variable.factor = FALSE )
id_tree = NULL
id_node = NULL
predictions[, id_tree := as.integer(id_tree)]
predictions[, id_node := as.integer(id_node)]
obs_depth = merge( predictions,
terminal_nodes,
by = c("id_tree", "id_node"))
return(predictions)
}
see <- isolation_forest(data)
View(see)
source('C:/Users/juraj/git_hub/IsolationForest/R/new_isolation_forest.R')
isolation_forest <- function( X,
n_tree = 100,
smpl_frac = 0.623,
mtry = NULL,
seed = 1071,
replace_smpl = FALSE,
respect_unord_fact = NULL,
n_threads = NULL )
{
set.seed(seed)
# 'response' variable is really just random noise
random_response_isof <- sample(1:nrow(X), nrow(X))
X <- data.frame(random_response_isof, X)
# fit ranger forest object
fitted_forest <- ranger::ranger( random_response_isof~.,
data = X,
mtry,
min.node.size = 1L,
splitrule = "extratrees",
num.random.splits = 1L,
num.trees = n_tree,
replace = replace_smpl,
sample.fraction = smpl_frac,
respect.unordered.factors = respect_unord_fact,
num.threads = n_threads )
# terminal depth
depth_terminal <- function( forest )
{
# workaround for cran - undefined variables problem
id_node <- NULL
depth <- NULL
terminal_depth <-
future.apply::future_lapply( 1:forest[["num.trees"]],
function(i){
# this extracts the i-th tree
tree <- ranger::treeInfo(forest, i)
# process tree
orig_tree <- data.table::data.table(tree)
tree <- data.table::melt( orig_tree[, c("nodeID", "leftChild", "rightChild")],
id.vars = "nodeID",
measure.vars = c("leftChild", "rightChild"),
na.rm = TRUE )
# create graph in 1-index mode
edgeMat     = as.matrix(tree[ , c("nodeID", "value")]) + 1L
treegraph   = igraph::graph_from_edgelist(edgeMat, directed = TRUE)
# get depths of terminal nodes
tnValues    = orig_tree[["nodeID"]][orig_tree[["terminal"]]]
depths      = igraph::distances(treegraph
, v    = 1L
, to   = tnValues + 1L # to 1-index mode
, mode = "out"
)
dim(depths) = NULL
res = data.table::data.table(id_node = tnValues, depth = depths)
return(res)})
terminal_depth = data.table::rbindlist(terminal_depth, idcol = "id_tree")
terminal_depth[ , id_node := as.integer(id_node)]
terminal_depth[ , depth   := as.integer(depth)]
return(terminal_depth)
}
terminal_nodes <- depth_terminal(fitted_forest)
# return(terminal_nodes)
# generate predictions from the fitted forest object
predictions <-
data.table::data.table( stats::predict( object = fitted_forest,
data = X,
type = "terminalNodes",
num.threads = n_threads )[["predictions"]])
# return(predictions)
data.table::setnames( predictions,
colnames(predictions),
as.character(1:ncol(predictions)))
return(predictions)
predictions[, id := .I]
predictions <- data.table::melt( predictions,
id.vars = "id",
variable.name = "id_tree",
value = "id_node",
variable.factor = FALSE )
id_tree = NULL
id_node = NULL
predictions[, id_tree := as.integer(id_tree)]
predictions[, id_node := as.integer(id_node)]
obs_depth = merge( predictions,
terminal_nodes,
by = c("id_tree", "id_node"))
return(predictions)
}
see <- isolation_forest(data)
View(see)
isolation_forest <- function( X,
n_tree = 100,
smpl_frac = 0.623,
mtry = NULL,
seed = 1071,
replace_smpl = FALSE,
respect_unord_fact = NULL,
n_threads = NULL )
{
set.seed(seed)
# 'response' variable is really just random noise
random_response_isof <- sample(1:nrow(X), nrow(X))
X <- data.frame(random_response_isof, X)
# fit ranger forest object
fitted_forest <- ranger::ranger( random_response_isof~.,
data = X,
mtry,
min.node.size = 1L,
splitrule = "extratrees",
num.random.splits = 1L,
num.trees = n_tree,
replace = replace_smpl,
sample.fraction = smpl_frac,
respect.unordered.factors = respect_unord_fact,
num.threads = n_threads )
# terminal depth
depth_terminal <- function( forest )
{
# workaround for cran - undefined variables problem
id_node <- NULL
depth <- NULL
terminal_depth <-
future.apply::future_lapply( 1:forest[["num.trees"]],
function(i){
# this extracts the i-th tree
tree <- ranger::treeInfo(forest, i)
# process tree
orig_tree <- data.table::data.table(tree)
tree <- data.table::melt( orig_tree[, c("nodeID", "leftChild", "rightChild")],
id.vars = "nodeID",
measure.vars = c("leftChild", "rightChild"),
na.rm = TRUE )
# create graph in 1-index mode
edgeMat     = as.matrix(tree[ , c("nodeID", "value")]) + 1L
treegraph   = igraph::graph_from_edgelist(edgeMat, directed = TRUE)
# get depths of terminal nodes
tnValues    = orig_tree[["nodeID"]][orig_tree[["terminal"]]]
depths      = igraph::distances(treegraph
, v    = 1L
, to   = tnValues + 1L # to 1-index mode
, mode = "out"
)
dim(depths) = NULL
res = data.table::data.table(id_node = tnValues, depth = depths)
return(res)})
terminal_depth = data.table::rbindlist(terminal_depth, idcol = "id_tree")
terminal_depth[ , id_node := as.integer(id_node)]
terminal_depth[ , depth   := as.integer(depth)]
return(terminal_depth)
}
terminal_nodes <- depth_terminal(fitted_forest)
# return(terminal_nodes)
# generate predictions from the fitted forest object
predictions <-
data.table::data.table( stats::predict( object = fitted_forest,
data = X,
type = "terminalNodes",
num.threads = n_threads )[["predictions"]])
# return(predictions)
data.table::setnames( predictions,
colnames(predictions),
as.character(1:ncol(predictions)))
# return(predictions)
predictions[, id := .I]
predictions <- data.table::melt( predictions,
id.vars = "id",
variable.name = "id_tree",
value = "id_node",
variable.factor = FALSE )
return(predictions)
id_tree = NULL
id_node = NULL
predictions[, id_tree := as.integer(id_tree)]
predictions[, id_node := as.integer(id_node)]
obs_depth = merge( predictions,
terminal_nodes,
by = c("id_tree", "id_node"))
return(predictions)
}
see <- isolation_forest(data)
View(see)
isolation_forest <- function( X,
n_tree = 100,
smpl_frac = 0.623,
mtry = NULL,
seed = 1071,
replace_smpl = FALSE,
respect_unord_fact = NULL,
n_threads = NULL )
{
set.seed(seed)
# 'response' variable is really just random noise
random_response_isof <- sample(1:nrow(X), nrow(X))
X <- data.frame(random_response_isof, X)
# fit ranger forest object
fitted_forest <- ranger::ranger( random_response_isof~.,
data = X,
mtry,
min.node.size = 1L,
splitrule = "extratrees",
num.random.splits = 1L,
num.trees = n_tree,
replace = replace_smpl,
sample.fraction = smpl_frac,
respect.unordered.factors = respect_unord_fact,
num.threads = n_threads )
# terminal depth
depth_terminal <- function( forest )
{
# workaround for cran - undefined variables problem
id_node <- NULL
depth <- NULL
terminal_depth <-
future.apply::future_lapply( 1:forest[["num.trees"]],
function(i){
# this extracts the i-th tree
tree <- ranger::treeInfo(forest, i)
# process tree
orig_tree <- data.table::data.table(tree)
tree <- data.table::melt( orig_tree[, c("nodeID", "leftChild", "rightChild")],
id.vars = "nodeID",
measure.vars = c("leftChild", "rightChild"),
na.rm = TRUE )
# create graph in 1-index mode
edgeMat     = as.matrix(tree[ , c("nodeID", "value")]) + 1L
treegraph   = igraph::graph_from_edgelist(edgeMat, directed = TRUE)
# get depths of terminal nodes
tnValues    = orig_tree[["nodeID"]][orig_tree[["terminal"]]]
depths      = igraph::distances(treegraph
, v    = 1L
, to   = tnValues + 1L # to 1-index mode
, mode = "out"
)
dim(depths) = NULL
res = data.table::data.table(id_node = tnValues, depth = depths)
return(res)})
terminal_depth = data.table::rbindlist(terminal_depth, idcol = "id_tree")
terminal_depth[ , id_node := as.integer(id_node)]
terminal_depth[ , depth   := as.integer(depth)]
return(terminal_depth)
}
terminal_nodes <- depth_terminal(fitted_forest)
# return(terminal_nodes)
# generate predictions from the fitted forest object
predictions <-
data.table::data.table( stats::predict( object = fitted_forest,
data = X,
type = "terminalNodes",
num.threads = n_threads )[["predictions"]])
# return(predictions)
data.table::setnames( predictions,
colnames(predictions),
as.character(1:ncol(predictions)))
# return(predictions)
predictions[, id := .I]
predictions <- data.table::melt( predictions,
id.vars = "id",
variable.name = "id_tree",
value = "id_node",
variable.factor = FALSE )
# return(predictions)
id_tree = NULL
id_node = NULL
predictions[, id_tree := as.integer(id_tree)]
predictions[, id_node := as.integer(id_node)]
obs_depth = merge( predictions,
terminal_nodes,
by = c("id_tree", "id_node"))
return(obs_depth)
return(predictions)
}
see <- isolation_forest(data)
View(see)
